this.workbox=this.workbox||{},this.workbox.backgroundSync=function(t,e,s,i){"use strict";try{self["workbox:background-sync:4.0.0"]&&_()}catch(t){}const n=2,r="workbox-background-sync",a="requests",c="queueName",o="workbox-background-sync",h=10080;class u{constructor(t){this.t=t,this.s=new s.DBWrapper(r,n,{onupgradeneeded:t=>this.i(t)})}async pushEntry(t){delete t.id,t.queueName=this.t,await this.s.add(a,t)}async unshiftEntry(t){const[e]=await this.s.getAllMatching(a,{count:1});e?t.id=e.id-1:delete t.id,t.queueName=this.t,await this.s.add(a,t)}async popEntry(){return this.o({direction:"prev"})}async shiftEntry(){return this.o({direction:"next"})}async o({direction:t}){const[e]=await this.s.getAllMatching(a,{direction:t,index:c,query:IDBKeyRange.only(this.t),count:1});if(e)return await this.s.delete(a,e.id),delete e.id,delete e.queueName,e}i(t){const e=t.target.result,s=t.target.transaction;let n=[];i.migrateDb(t,{v1:t=>{if(e.objectStoreNames.contains(a)){s.objectStore(a).openCursor().onsuccess=(({target:s})=>{const i=s.result;i?(n.push(i.value),i.continue()):(e.deleteObjectStore(a),t())})}else t()},v2:t=>{const s=e.createObjectStore(a,{autoIncrement:!0,keyPath:"id"});if(s.createIndex(c,c,{unique:!1}),n.length)for(const t of n){const{queueName:e,storableRequest:i}=t,n=i.timestamp,r=Object.assign(i.requestInit,{url:i.url});s.add({queueName:e,timestamp:n,requestData:r})}t()}})}}const y=["method","referrer","referrerPolicy","mode","credentials","cache","redirect","integrity","keepalive"];class w{static async fromRequest(t){const e={url:t.url,headers:{}};"GET"!==t.method&&(e.body=await t.clone().blob());for(const[s,i]of t.headers.entries())e.headers[s]=i;for(const s of y)void 0!==t[s]&&(e[s]=t[s]);return new w(e)}constructor(t){this.h=t}toObject(){const t=Object.assign({},this.h);return t.headers=Object.assign({},this.h.headers),t.body&&(t.body=t.body.slice()),t}toRequest(){return new Request(this.h.url,this.h)}clone(){return new w(this.toObject())}}const d=new Set;class f{constructor(t,{onSync:s,maxRetentionTime:i}={}){if(d.has(t))throw new e.WorkboxError("duplicate-queue-name",{name:t});d.add(t),this.u=t,this.q=s||this.replayRequests,this.l=i||h,this.m=new u(this.u),this.p()}get name(){return this.u}async pushRequest(t){await this.g(t,"push")}async unshiftRequest(t){await this.g(t,"unshift")}async popRequest(){return this.R("pop")}async shiftRequest(){return this.R("shift")}async g({request:t,metadata:e,timestamp:s=Date.now()},i){const n={requestData:(await w.fromRequest(t.clone())).toObject(),timestamp:s};e&&(n.metadata=e),await this.m[`${i}Entry`](n),await this.registerSync()}async R(t){const e=Date.now(),s=await this.m[`${t}Entry`]();if(s){const i=60*this.l*1e3;return e-s.timestamp>i?this.R(t):(s.request=new w(s.requestData).toRequest(),delete s.requestData,s)}}async replayRequests(){let t;for(;t=await this.shiftRequest();)try{await fetch(t.request)}catch(s){throw await this.unshiftRequest(t),new e.WorkboxError("queue-replay-failed",{name:this.u})}}async registerSync(){if("sync"in registration)try{await registration.sync.register(`${o}:${this.u}`)}catch(t){}}p(){"sync"in registration?self.addEventListener("sync",t=>{t.tag===`${o}:${this.u}`&&t.waitUntil(this.q({queue:this}))}):this.q({queue:this})}static get k(){return d}}return t.Queue=f,t.Plugin=class{constructor(...t){this.v=new f(...t),this.fetchDidFail=this.fetchDidFail.bind(this)}async fetchDidFail({request:t}){await this.v.pushRequest({request:t})}},t}({},workbox.core._private,workbox.core._private,workbox.core._private);
//# sourceMappingURL=workbox-background-sync.prod.js.map
